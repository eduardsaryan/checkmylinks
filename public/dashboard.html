// Add these routes to your existing Express router

// Get user profile info
app.get('/api/auth/me', authenticateToken, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, email, created_at FROM users WHERE id = $1',
      [req.userId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get dashboard statistics
app.get('/api/scans/stats', authenticateToken, async (req, res) => {
  try {
    const userId = req.userId;
    const currentMonth = new Date();
    currentMonth.setDate(1);
    currentMonth.setHours(0, 0, 0, 0);
    
    // Total scans for user
    const totalScansResult = await pool.query(
      'SELECT COUNT(*) as count FROM scans WHERE user_id = $1',
      [userId]
    );
    
    // Monthly scans for user
    const monthlyScansResult = await pool.query(
      'SELECT COUNT(*) as count FROM scans WHERE user_id = $1 AND created_at >= $2',
      [userId, currentMonth]
    );
    
    // Total broken links found
    const totalBrokenLinksResult = await pool.query(`
      SELECT SUM(s.broken_links) as total 
      FROM scans s 
      WHERE s.user_id = $1 AND s.status = 'completed' AND s.broken_links IS NOT NULL
    `, [userId]);
    
    // Monthly broken links found
    const monthlyBrokenLinksResult = await pool.query(`
      SELECT SUM(s.broken_links) as total 
      FROM scans s 
      WHERE s.user_id = $1 AND s.status = 'completed' AND s.created_at >= $2 AND s.broken_links IS NOT NULL
    `, [userId, currentMonth]);
    
    res.json({
      totalScans: parseInt(totalScansResult.rows[0].count) || 0,
      monthlyScans: parseInt(monthlyScansResult.rows[0].count) || 0,
      totalBrokenLinks: parseInt(totalBrokenLinksResult.rows[0].total) || 0,
      monthlyBrokenLinks: parseInt(monthlyBrokenLinksResult.rows[0].total) || 0
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update your existing GET /api/scans route to support pagination and filters
app.get('/api/scans', authenticateToken, async (req, res) => {
  try {
    const userId = req.userId;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 15;
    const offset = (page - 1) * limit;
    
    // Build WHERE clause based on filters
    let whereConditions = ['user_id = $1'];
    let params = [userId];
    let paramCount = 1;
    
    if (req.query.status) {
      paramCount++;
      whereConditions.push(`status = $${paramCount}`);
      params.push(req.query.status);
    }
    
    if (req.query.dateFrom) {
      paramCount++;
      whereConditions.push(`created_at >= $${paramCount}`);
      params.push(req.query.dateFrom);
    }
    
    if (req.query.dateTo) {
      paramCount++;
      whereConditions.push(`created_at <= $${paramCount}::date + interval '1 day'`);
      params.push(req.query.dateTo);
    }
    
    const whereClause = whereConditions.join(' AND ');
    
    // Get total count for pagination
    const countResult = await pool.query(
      `SELECT COUNT(*) as count FROM scans WHERE ${whereClause}`,
      params
    );
    
    const totalCount = parseInt(countResult.rows[0].count);
    const totalPages = Math.ceil(totalCount / limit);
    
    // Get scans with pagination
    const scansResult = await pool.query(`
      SELECT 
        id, 
        url, 
        status, 
        total_links, 
        broken_links, 
        created_at, 
        completed_at
      FROM scans 
      WHERE ${whereClause}
      ORDER BY created_at DESC 
      LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}
    `, [...params, limit, offset]);
    
    res.json({
      scans: scansResult.rows,
      pagination: {
        currentPage: page,
        totalPages: totalPages,
        totalCount: totalCount,
        hasMore: page < totalPages
      }
    });
  } catch (error) {
    console.error('Error fetching scans:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update your existing GET /api/scans/:id route to include scan results
app.get('/api/scans/:id', authenticateToken, async (req, res) => {
  try {
    const scanId = req.params.id;
    const userId = req.userId;
    
    // Get scan details
    const scanResult = await pool.query(`
      SELECT 
        id, 
        url, 
        status, 
        total_links, 
        broken_links, 
        created_at, 
        completed_at
      FROM scans 
      WHERE id = $1 AND user_id = $2
    `, [scanId, userId]);
    
    if (scanResult.rows.length === 0) {
      return res.status(404).json({ error: 'Scan not found' });
    }
    
    const scan = scanResult.rows[0];
    
    // Get scan results (broken links only for performance)
    const resultsQuery = await pool.query(`
      SELECT 
        url, 
        status_code, 
        found_on, 
        error_message
      FROM scan_results 
      WHERE scan_id = $1 AND status_code != 200
      ORDER BY url
    `, [scanId]);
    
    scan.scan_results = resultsQuery.rows;
    
    res.json(scan);
  } catch (error) {
    console.error('Error fetching scan details:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Optional: Add endpoint to get scan results with pagination (for large scans)
app.get('/api/scans/:id/results', authenticateToken, async (req, res) => {
  try {
    const scanId = req.params.id;
    const userId = req.userId;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;
    const offset = (page - 1) * limit;
    const brokenOnly = req.query.brokenOnly === 'true';
    
    // Verify scan belongs to user
    const scanCheck = await pool.query(
      'SELECT id FROM scans WHERE id = $1 AND user_id = $2',
      [scanId,